#!/bin/bash
# Description: script that loops through a list of Pokémon [Bulbasaur, Ivysaur, Venusaur, Charmander, Charmeleon]
# If an API request fails, implement a retry mechanism that attempts the request up to 3 times before 
# logging the error and skipping to the next Pokémon.
# Usage: ./batch_processing.sh
# Requirements: curl, jq
API_BASE_URL="https://pokeapi.co/api/v2/pokemon/"
DEFAULT_POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
# Output file to store the JSON data

OUTPUT_FILE="pokemon_data"
ERROR_LOG="errors.txt"
cleanup() {
  if [[ -f "$OUTPUT_FILE" && ! -s "$OUTPUT_FILE" ]]; then
    rm -f "$OUTPUT_FILE"
  fi
}
trap cleanup EXIT
# Function to fetch Pokémon data
# $(echo "$pokemon" | sed 's/^./\U&/')
# check if pokemon name is valid and  potential errors (e.g., network issues, invalid Pokémon names)

check_network_connection() {
    if ! curl -s --head "$API_BASE_URL" | grep "200 OK" > /dev/null; then
        echo "Error: Unable to connect to the Pokémon API. Please check your network connection." >&2
        exit 1
    fi
}
check_valid_pokemon_name() {
    local pokemon="$1"
    if ! curl -sSf "$API_BASE_URL/$pokemon" > /dev/null; then
        echo "Error: Invalid Pokémon name '$pokemon'. Please check the name and try again." >&2
        exit 1
    fi
}
retry_count=0
max_retries=3
fetch_retry(){
    local pokemon="$1"
    local api_url="$API_BASE_URL/$pokemon"
    while [[ $retry_count -lt $max_retries ]]; do
        if curl -sSf "$api_url" -o "${OUTPUT_FILE}/$(echo "$pokemon" | sed 's/^./\U&/').json"; then
        # echo "Successfully fetched data for '$pokemon'."
        return 0
        else
        echo "Attempt $((retry_count + 1)) failed for '$pokemon'. Retrying..."
        ((retry_count++))
        sleep 2 # Wait before retrying
        fi
    done
    echo "Failed to fetch data for '$pokemon' after $max_retries attempts." >&2
    return 1
}
fetch_pokemon() {
  local pokemon_list=("$@")
  for pokemon in "${pokemon_list[@]}"; do
    local api_url="$API_BASE_URL/$pokemon"
    echo "Fetching data for '$pokemon'..."
    if ! fetch_retry $pokemon && check_network_connection && check_valid_pokemon_name 2>> "$ERROR_LOG"; then
      echo "Error: Failed to fetch data for '$pokemon'. Check $ERROR_LOG for details." >&2
      continue
    fi
    echo "Saved data to ${OUTPUT_FILE}/$(echo "$pokemon" | sed 's/^./\U&/').json "
    delay=$((RANDOM % 3 + 1)) # Random delay between 1 and 3 seconds
    # echo "Waiting for $delay seconds before the next request..."
    sleep "$delay"
    # extract_pokemon_data "${OUTPUT_FILE}/$(echo "$pokemon" | sed 's/^./\U&/').json"
  done
}

#  curl -sSf "$api_url" -o "${OUTPUT_FILE}/$(echo "$pokemon" | sed 's/^./\U&/').json" 
# # Function to extract Pokémon data
# extract_pokemon_data() {
#   local json_file="$1"
#   if [[ ! -f "$json_file" ]]; then
#     echo "Error: JSON file '$json_file' does not exist." >&2
#     return 1
#   fi

#   if ! command -v jq &> /dev/null; then
#     echo "Error: jq is not installed. Please install it to run this script." >&2
#     return 1
#   fi

#   # Extract data using jq
#   local name=$(jq -r '.name' "$json_file")
#   local height=$(jq -r '.height' "$json_file")
#   local weight=$(jq -r '.weight' "$json_file")
#   local type=$(jq -r '.types[0].type.name' "$json_file")

#   if [[ -z "$name" || -z "$height" || -z "$weight" || -z "$type" ]]; then
#     echo "Error: Failed to extract data from '$json_file'. Check $ERROR_LOG for details." >&2
#     return 1
#   fi

#   # Convert weight from hectograms to kilograms
#   formatted_weight=$(awk "BEGIN { print $weight / 10 }")
#   # Convert height from decimetres to metres
#   formatted_height=$(awk "BEGIN { print $height / 10 }")
  
#   name=$(echo "$name" | sed 's/^./\U&/')
#   echo "$name is of type $type, weighs ${formatted_weight}kg, and is ${formatted_height}m tall."
# }
# Main execution
fetch_pokemon "${DEFAULT_POKEMON_LIST[@]}"
# Cleanup
cleanup
# Exit with success status
exit 0
